"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dateExtensions = void 0;
const ExpressionError_1 = require("./../ExpressionError");
const luxon_1 = require("luxon");
const utils_1 = require("./utils");
const DURATION_MAP = {
    day: 'days',
    month: 'months',
    year: 'years',
    week: 'weeks',
    hour: 'hours',
    minute: 'minutes',
    second: 'seconds',
    millisecond: 'milliseconds',
    ms: 'milliseconds',
    sec: 'seconds',
    secs: 'seconds',
    hr: 'hours',
    hrs: 'hours',
    min: 'minutes',
    mins: 'minutes',
};
const DATETIMEUNIT_MAP = {
    days: 'day',
    months: 'month',
    years: 'year',
    hours: 'hour',
    minutes: 'minute',
    seconds: 'second',
    milliseconds: 'millisecond',
    hrs: 'hour',
    hr: 'hour',
    mins: 'minute',
    min: 'minute',
    secs: 'second',
    sec: 'second',
    ms: 'millisecond',
};
function isDateTime(date) {
    if (date) {
        return luxon_1.DateTime.isDateTime(date);
    }
    return false;
}
function generateDurationObject(durationValue, unit) {
    const convertedUnit = DURATION_MAP[unit] || unit;
    return { [`${convertedUnit}`]: durationValue };
}
function beginningOf(date, extraArgs) {
    const [unit = 'week'] = extraArgs;
    if (isDateTime(date)) {
        return date.startOf(DATETIMEUNIT_MAP[unit] || unit).toJSDate();
    }
    const dateTime = luxon_1.DateTime.fromJSDate(date);
    return dateTime.startOf(DATETIMEUNIT_MAP[unit] || unit).toJSDate();
}
function endOfMonth(date) {
    if (isDateTime(date)) {
        return date.endOf('month').toJSDate();
    }
    return luxon_1.DateTime.fromJSDate(date).endOf('month').toJSDate();
}
function extract(inputDate, extraArgs) {
    let [part = 'week'] = extraArgs;
    let date = inputDate;
    if (isDateTime(date)) {
        date = date.toJSDate();
    }
    if (part === 'yearDayNumber') {
        const firstDayOfTheYear = new Date(date.getFullYear(), 0, 0);
        const diff = date.getTime() -
            firstDayOfTheYear.getTime() +
            (firstDayOfTheYear.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000;
        return Math.floor(diff / (1000 * 60 * 60 * 24));
    }
    if (part === 'week') {
        part = 'weekNumber';
    }
    return luxon_1.DateTime.fromJSDate(date).get(DATETIMEUNIT_MAP[part] || part);
}
function format(date, extraArgs) {
    const [dateFormat, localeOpts = {}] = extraArgs;
    if (isDateTime(date)) {
        return date.toFormat(dateFormat, { ...localeOpts });
    }
    return luxon_1.DateTime.fromJSDate(date).toFormat(dateFormat, { ...localeOpts });
}
function isBetween(date, extraArgs) {
    if (extraArgs.length !== 2) {
        throw new ExpressionError_1.ExpressionExtensionError('isBetween(): expected exactly two args');
    }
    const [first, second] = extraArgs;
    const firstDate = (0, utils_1.convertToDateTime)(first);
    const secondDate = (0, utils_1.convertToDateTime)(second);
    if (!firstDate || !secondDate) {
        return;
    }
    if (firstDate > secondDate) {
        return secondDate < date && date < firstDate;
    }
    return secondDate > date && date > firstDate;
}
function isDst(date) {
    if (isDateTime(date)) {
        return date.isInDST;
    }
    return luxon_1.DateTime.fromJSDate(date).isInDST;
}
function isInLast(date, extraArgs) {
    const [durationValue = 0, unit = 'minutes'] = extraArgs;
    const dateInThePast = luxon_1.DateTime.now().minus(generateDurationObject(durationValue, unit));
    let thisDate = date;
    if (!isDateTime(thisDate)) {
        thisDate = luxon_1.DateTime.fromJSDate(thisDate);
    }
    return dateInThePast <= thisDate && thisDate <= luxon_1.DateTime.now();
}
function isWeekend(date) {
    let DAYS;
    (function (DAYS) {
        DAYS[DAYS["saturday"] = 6] = "saturday";
        DAYS[DAYS["sunday"] = 7] = "sunday";
    })(DAYS || (DAYS = {}));
    if (isDateTime(date)) {
        return [DAYS.saturday, DAYS.sunday].includes(date.weekday);
    }
    return [DAYS.saturday, DAYS.sunday].includes(luxon_1.DateTime.fromJSDate(date).weekday);
}
function minus(date, extraArgs) {
    if (isDateTime(date) && extraArgs.length === 1) {
        return date.minus(extraArgs[0]);
    }
    const [durationValue = 0, unit = 'minutes'] = extraArgs;
    if (isDateTime(date)) {
        return date.minus(generateDurationObject(durationValue, unit)).toJSDate();
    }
    return luxon_1.DateTime.fromJSDate(date).minus(generateDurationObject(durationValue, unit)).toJSDate();
}
function plus(date, extraArgs) {
    if (isDateTime(date) && extraArgs.length === 1) {
        return date.plus(extraArgs[0]);
    }
    const [durationValue = 0, unit = 'minutes'] = extraArgs;
    if (isDateTime(date)) {
        return date.plus(generateDurationObject(durationValue, unit)).toJSDate();
    }
    return luxon_1.DateTime.fromJSDate(date).plus(generateDurationObject(durationValue, unit)).toJSDate();
}
endOfMonth.doc = {
    name: 'endOfMonth',
    returnType: 'Date',
    description: 'Transforms a date to the last possible moment that lies within the month',
};
isDst.doc = {
    name: 'isDst',
    returnType: 'boolean',
    description: 'Checks if a Date is within Daylight Savings Time',
};
isWeekend.doc = {
    name: 'isWeekend',
    returnType: 'boolean',
    description: 'Checks if the Date falls on a Saturday or Sunday',
};
beginningOf.doc = {
    name: 'beginningOf',
    returnType: 'Date',
};
extract.doc = {
    name: 'extract',
    returnType: 'number',
};
format.doc = {
    name: 'format',
    returnType: '(?)',
};
isBetween.doc = {
    name: 'isBetween',
    returnType: 'boolean',
};
isInLast.doc = {
    name: 'isInLast',
    returnType: 'boolean',
};
minus.doc = {
    name: 'minus',
    returnType: 'Date',
};
plus.doc = {
    name: 'plus',
    returnType: 'Date',
};
exports.dateExtensions = {
    typeName: 'Date',
    functions: {
        beginningOf,
        endOfMonth,
        extract,
        isBetween,
        isDst,
        isInLast,
        isWeekend,
        minus,
        plus,
        format,
    },
};
//# sourceMappingURL=DateExtensions.js.map